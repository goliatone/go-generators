package config

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"os"
	"strings"

	"github.com/dave/jennifer/jen"
	common "github.com/goliatone/go-generators/internal/common/generator"
	"golang.org/x/tools/imports"
)

type Generator struct {
	*common.BaseGenerator
}

// structInfo holds information about a struct type
type structInfo struct {
	name   string
	fields []fieldInfo
}

// fieldInfo holds information about a struct field
type fieldInfo struct {
	name     string
	typeName string
	isStruct bool // Whether this field is itself a struct type
}

// New creates a new config-getters generator that writes to stdout
func New() *Generator {
	return &Generator{
		BaseGenerator: common.NewBaseGenerator("config-getters", os.Stdout, false),
	}
}

// New creates a new config-getters generator with the provided writer
func NewWithWriter(w io.Writer) *Generator {
	return &Generator{
		BaseGenerator: common.NewBaseGenerator("config-getters", w, true),
	}
}

// Generate implements the common.Generator interface.
func (g *Generator) Generate(opts common.Options) error {
	return g.generateGetters(opts)
}

func (g *Generator) generateGetters(opts common.Options) error {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, opts.InputFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse input file: %v", err)
	}

	structs := make([]structInfo, 0)
	structTypes := make(map[string]bool)

	// collect all struct types
	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if _, ok := typeSpec.Type.(*ast.StructType); ok {
				structTypes[typeSpec.Name.Name] = true
			}
		}
		return true
	})

	// collect struct info and fields
	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if structType, ok := typeSpec.Type.(*ast.StructType); ok {
				fields := make([]fieldInfo, 0)
				for _, field := range structType.Fields.List {
					if len(field.Names) > 0 {
						typeName := getFieldTypeName(field.Type)
						fields = append(fields, fieldInfo{
							name:     field.Names[0].Name,
							typeName: typeName,
							isStruct: structTypes[typeName],
						})
					}
				}
				structs = append(structs, structInfo{
					name:   typeSpec.Name.Name,
					fields: fields,
				})
			}
		}
		return true
	})

	f := jen.NewFile(node.Name.Name)

	// This comment triggers a pop-up notice in VS Code reminding you to
	// not edit the code. Nice!
	f.HeaderComment(
		fmt.Sprintf("// Code generated by %s; DO NOT EDIT.\n", g.Name),
	)

	//TODO: we might be able to remove this
	packages := common.CollectImports(node)
	for _, imp := range packages {
		path := strings.Trim(imp.Path.Value, `"`)
		if imp.Name != nil {
			f.ImportAlias(path, imp.Name.Name)
		} else {
			f.ImportName(path, path)
		}
	}

	// Generate getters for each struct
	for _, st := range structs {
		f.Comment(fmt.Sprintf("// %s Getters", st.name))
		f.Line()
		generateStructGetters(f, st)
		f.Line()
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		return fmt.Errorf("failed to render code: %v", err)
	}

	// process the generated code using goimports
	// to format the code and adjust the imports
	processed, err := imports.Process(opts.OutputFile, buf.Bytes(), nil)
	if err != nil {
		return fmt.Errorf("failed to process imports on generated code: %v", err)
	}

	// If we provided a writer, we output there.
	// e.g. in tests to generate golden files
	if g.ToWritter {
		return common.Render(processed, g.Writer)
	}

	if err := common.CreateOutputDir(opts.OutputFile); err != nil {
		return fmt.Errorf("failed to create output directory: %v", err)
	}

	if err := os.WriteFile(opts.OutputFile, processed, 0644); err != nil {
		return fmt.Errorf("failed to write processed code to file: %v", err)
	}

	fmt.Printf("Successfully generated config getters in %s\n", opts.OutputFile)
	return nil
}

func generateStructGetters(f *jen.File, st structInfo) {
	// Generate getter for each field
	for _, field := range st.fields {
		// Generate the getter method
		f.Func().
			Params(jen.Id(strings.ToLower(st.name[0:1])).Id(st.name)).
			Id(fmt.Sprintf("Get%s", field.name)).
			Params().
			Id(field.typeName).
			// Type().Add(jen.Qual("", field.typeName)).
			Block(
				jen.Return(jen.Id(strings.ToLower(st.name[0:1])).Dot(field.name)),
			)
		f.Line()
	}
}

func getFieldTypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + getFieldTypeName(t.X)
	case *ast.SelectorExpr:
		// qualified types like pkg.Type
		if pkgIdent, ok := t.X.(*ast.Ident); ok {
			return fmt.Sprintf("%s.%s", pkgIdent.Name, t.Sel.Name)
		}
		return t.Sel.Name
	case *ast.ArrayType:
		return "[]" + getFieldTypeName(t.Elt)
	case *ast.MapType:
		return fmt.Sprintf("map[%s]%s", getFieldTypeName(t.Key), getFieldTypeName(t.Value))
	case *ast.InterfaceType:
		//  "any" for empty interface
		if len(t.Methods.List) == 0 {
			return "any"
		}
		// TODO: non empty interface, implement
		return "interface{...}"
	case *ast.FuncType:
		return common.FormatFuncType(t)
	case *ast.ChanType:
		var dir string
		switch t.Dir {
		case ast.SEND:
			dir = "chan<- "
		case ast.RECV:
			dir = "<-chan "
		default:
			dir = "chan "
		}
		return dir + getFieldTypeName(t.Value)
	default:
		return ""
	}
}

package appconfig

import (
	"fmt"
	"os"

	"github.com/ettle/strcase"
	"gopkg.in/yaml.v3"
)

// ExtensionField defines metadata for a single field.
type ExtensionField struct {
	Name      string            `yaml:"name"`     // field name as generated by default (e.g. "AssetsFs")
	Overwrite string            `yaml:"override"` // field name to use in the final struct (e.g. "AssetsFS")
	Type      string            `yaml:"type"`     // type override (e.g. "fs.FS")
	Setter    bool              `yaml:"setter"`
	Tags      map[string]string `yaml:"tags"`
}

// ExtensionConfig maps a normalized key (for a struct) to its list of extension fields.
type ExtensionConfig map[string][]ExtensionField

func loadExtensionFile(filepath string) (ExtensionConfig, error) {
	raw, err := os.ReadFile(filepath)
	if err != nil {
		return nil, fmt.Errorf("failed to read extension file: %v", err)
	}

	var rawConfig map[string]any
	if err := yaml.Unmarshal(raw, &rawConfig); err != nil {
		return nil, fmt.Errorf("failed to unmarshal extension file: %v", err)
	}

	config := make(ExtensionConfig)
	processRawConfig("", rawConfig, config)

	fmt.Printf("Loaded extension file: %s\n", filepath)

	return config, nil
}

func processRawConfig(prefix string, raw map[string]any, config ExtensionConfig) {
	for k, v := range raw {
		path := k
		if prefix != "" {
			path = prefix + "." + k
		}

		normalizedPath := normalizeKey(path)

		switch val := v.(type) {
		case []any:
			fields := []ExtensionField{}
			for _, item := range val {
				if fieldMap, ok := item.(map[string]any); ok {
					field := ExtensionField{}
					if name, ok := fieldMap["name"].(string); ok {
						field.Name = name
					}

					if override, ok := fieldMap["override"].(string); ok {
						field.Overwrite = override
					}

					if typ, ok := fieldMap["type"].(string); ok {
						field.Type = typ
					}

					if setter, ok := fieldMap["setter"].(bool); ok {
						field.Setter = setter
					}

					if tagsMap, ok := fieldMap["tags"].(map[string]any); ok {
						field.Tags = make(map[string]string)
						for tk, tv := range tagsMap {
							if strv, ok := tv.(string); ok {
								field.Tags[tk] = strv
							}
						}
					}

					fields = append(fields, field)
				}
			}
			config[normalizedPath] = fields

		case map[string]any:
			// found a nested structure, process it recursively
			processRawConfig(path, val, config)
		}
	}
}

func normalizeKey(s string) string {
	// ViewConfig => view_config
	return strcase.ToSnake(s)
}

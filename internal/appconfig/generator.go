package appconfig

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"os"
	"sort"

	"github.com/dave/jennifer/jen"
	"github.com/ettle/strcase"
	"github.com/gertd/go-pluralize"
	common "github.com/goliatone/go-generators/internal/common/generator"
)

var pluralizer = pluralize.NewClient()

// Generator implements the app-config generator
type Generator struct {
	*common.BaseGenerator
}

// New creates a new app-config generator that writes to stdout
func New() *Generator {
	return NewWithWriter(os.Stdout)
}

// NewWithWriter creates a new app-config generator with the provided writer
func NewWithWriter(w io.Writer) *Generator {
	return &Generator{
		BaseGenerator: common.NewBaseGenerator("app-config", w, true),
	}
}

func unmarshalFile(filepath string) (any, error) {
	data, err := os.ReadFile(filepath)
	if err != nil {
		return nil, fmt.Errorf("failed to read input file: %v", err)
	}

	var jsonData any
	if err := json.Unmarshal(data, &jsonData); err != nil {
		return nil, fmt.Errorf("failed to unmarshal JSON: %v", err)
	}

	return jsonData, nil
}

// Generate implements the Generator interface
func (g *Generator) Generate(opts common.Options) error {
	return g.generateAppConfig(opts)
}

func (g *Generator) generateAppConfig(opts common.Options) error {

	jsonData, err := unmarshalFile(opts.InputFile)
	if err != nil {
		return err
	}

	// we expect a top-level JSON object
	rootObj, ok := jsonData.(map[string]any)
	if !ok {
		return fmt.Errorf("expected top-level JSON object")
	}

	types := make(map[string]*StructDef)

	// process the top level object as type "Config"
	processObject("Config", rootObj, types)

	packageName := opts.PackageName
	if packageName == "" {
		packageName = "config"
	}
	f := jen.NewFile(packageName)

	f.HeaderComment(fmt.Sprintf("// Code generated by %s; DO NOT EDIT.", g.Name))

	// we now generate the types,
	// first output "Config" and then the rest
	if def, ok := types["Config"]; ok {
		generateStruct(f, def)
		delete(types, "Config")
	}

	var typeNames []string
	for tName := range types {
		typeNames = append(typeNames, tName)
	}
	sort.Strings(typeNames)
	for _, tName := range typeNames {
		generateStruct(f, types[tName])
	}

	if opts.OutputFile != "" {
		if err := common.CreateOutputDir(opts.OutputFile); err != nil {
			return fmt.Errorf("failed to create output directory: %v", err)
		}

		if err := common.CreateOutputFile(opts.OutputFile, f); err != nil {
			return fmt.Errorf("failed to render code: %v", err)
		}
		fmt.Printf("Successfully generated config structs in %s\n", opts.OutputFile)
		return nil
	}

	if g.ToWritter {
		return f.Render(g.Writer)
	}

	return errors.New("writer was not specified, nor the output path")
}

// StructDef represents a Go struct definition
type StructDef struct {
	Name   string
	Fields []FieldDef
}

// FieldDef represents a field within a struct.
type FieldDef struct {
	FieldName string // Go field name (exported)
	TypeName  string // Field type (e.g. string, bool, Database, []User, etc.)
	JSONKey   string // Original JSON key for the koanf tag.
}

// processObject recursively processes a JSON object into a StructDef.
// It uses the given typeName (e.g. "Config", "Database") and
// stores the result in the types map.
func processObject(typeName string, obj map[string]any, types map[string]*StructDef) {
	if _, exists := types[typeName]; exists {
		return
	}
	def := &StructDef{
		Name:   typeName,
		Fields: []FieldDef{},
	}
	types[typeName] = def

	keys := make([]string, 0, len(obj))
	for k := range obj {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for key, val := range obj {
		fieldName := toCamel(key)
		var typeNameField string
		switch v := val.(type) {
		case map[string]any:
			// nested objects we create a new type
			nestedTypeName := toCamel(key)
			typeNameField = nestedTypeName
			processObject(nestedTypeName, v, types)
		case []any:
			// inspect the first element to infer type
			if len(v) > 0 {
				if elemObj, ok := v[0].(map[string]any); ok {
					singular := singularize(toCamel(key))
					typeNameField = "[]" + singular
					processObject(singular, elemObj, types)
				} else {
					// is an array of primitives, we use type of first element
					elemType := inferBasicType(v[0])
					typeNameField = "[]" + elemType
				}
			} else {
				//empty array defaults to []any
				typeNameField = "[]any"
			}
		default:
			// primitive values
			typeNameField = inferBasicType(v)
		}

		def.Fields = append(def.Fields, FieldDef{
			FieldName: fieldName,
			TypeName:  typeNameField,
			JSONKey:   key,
		})
	}

	sort.Slice(def.Fields, func(i, j int) bool {
		return def.Fields[i].FieldName < def.Fields[j].FieldName
	})
}

// inferBasicType returns the Go type for a given JSON primitive
func inferBasicType(val any) string {
	switch val.(type) {
	case string:
		return "string"
	case bool:
		return "bool"
	case float64:
		//NOTE: All numbers are unmarshaled as float64
		return "float64"
	default:
		return "any"
	}
}

func generateStruct(f *jen.File, def *StructDef) {
	fields := []jen.Code{}
	for _, field := range def.Fields {
		fields = append(fields,
			jen.Id(field.FieldName).Id(field.TypeName).Tag(map[string]string{"koanf": field.JSONKey}),
		)
	}

	f.Type().Id(def.Name).Struct(fields...)
	f.Line()
}

func toCamel(s string) string {
	if s == "" {
		return ""
	}
	return strcase.ToGoPascal(s)
}

func singularize(s string) string {
	return pluralizer.Singular(s)
}

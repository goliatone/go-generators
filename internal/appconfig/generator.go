package appconfig

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path"
	"sort"
	"strings"

	"github.com/BurntSushi/toml"
	"github.com/dave/jennifer/jen"
	"github.com/ettle/strcase"
	"github.com/gertd/go-pluralize"
	common "github.com/goliatone/go-generators/internal/common/generator"
	"golang.org/x/tools/imports"
	"gopkg.in/yaml.v3"
)

var pluralizer = pluralize.NewClient()

var (
	DefaultStructName  = "Config"
	DefaultPackageName = "config"
)

// Generator implements the app-config generator
type Generator struct {
	*common.BaseGenerator
}

// New creates a new app-config generator that writes to stdout
func New() *Generator {
	return &Generator{
		BaseGenerator: common.NewBaseGenerator("app-config", os.Stdout, false),
	}
}

// NewWithWriter creates a new app-config generator with the provided writer
func NewWithWriter(w io.Writer) *Generator {
	return &Generator{
		BaseGenerator: common.NewBaseGenerator("app-config", w, true),
	}
}

func unmarshalFile(filepath string) (any, error) {
	raw, err := os.ReadFile(filepath)
	if err != nil {
		return nil, fmt.Errorf("failed to read input file: %v", err)
	}

	var data any

	// check for file extension
	ext := path.Ext(filepath)
	switch ext {
	case ".json":
		if err := json.Unmarshal(raw, &data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal JSON: %v", err)
		}
	case ".yml", ".yaml":
		if err := yaml.Unmarshal(raw, &data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal YAML: %v", err)
		}
	case ".toml":
		if err := toml.Unmarshal(raw, &data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal JSON: %v", err)
		}
	default:
		return nil, fmt.Errorf("unknown extension: %s", ext)
	}

	return data, nil
}

// Generate implements the Generator interface
func (g *Generator) Generate(opts common.Options) error {
	return g.generateAppConfig(opts)
}

func (g *Generator) generateAppConfig(opts common.Options) error {
	data, err := unmarshalFile(opts.InputFile)
	if err != nil {
		return err
	}

	// we expect a top-level JSON object
	rootObj, ok := data.(map[string]any)
	if !ok {
		return fmt.Errorf("expected top-level JSON object")
	}

	types := make(map[string]*StructDef)

	ext := make(ExtensionConfig)
	if opts.ExtensionFile != "" {
		fmt.Println("Loading extension file...")
		ext, err = loadExtensionFile(opts.ExtensionFile)
		if err != nil {
			return err
		}
	}

	structName := opts.StructName
	if structName == "" {
		structName = DefaultStructName
	}

	packageName := opts.PackageName
	if packageName == "" {
		packageName = DefaultPackageName
	}

	// process the top level object as type "Config"
	processObject(structName, rootObj, types, ext, "")

	// remove orphaned types from ovewriting stuff
	types = pruneTypes(structName, types)

	f := jen.NewFile(packageName)

	f.HeaderComment(fmt.Sprintf("// Code generated by %s; DO NOT EDIT.", g.Name))

	// we now generate the types,
	// first output "Config" and then the rest
	if def, ok := types[structName]; ok {
		generateStruct(f, def)
		delete(types, structName)
	}

	var typeNames []string
	for tName := range types {
		typeNames = append(typeNames, tName)
	}
	sort.Strings(typeNames)
	for _, tName := range typeNames {
		generateStruct(f, types[tName])
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		return fmt.Errorf("failed to render code: %v", err)
	}

	// process the generated code using goimports
	// to format the code and adjust the imports
	processed, err := imports.Process(opts.OutputFile, buf.Bytes(), nil)
	if err != nil {
		return fmt.Errorf("failed to process imports on generated code: %v", err)
	}

	// If we provided a writer, we output there.
	// e.g. in tests to generate golden files
	if g.ToWritter {
		return common.Render(processed, g.Writer)
	}

	if err := common.CreateOutputDir(opts.OutputFile); err != nil {
		return fmt.Errorf("failed to create output directory: %v", err)
	}

	if err := os.WriteFile(opts.OutputFile, processed, 0644); err != nil {
		return fmt.Errorf("failed to write processed code to file: %v", err)
	}

	fmt.Printf("Successfully generated app %s in %s\n", opts.StructName, opts.OutputFile)
	return nil
}

// StructDef represents a Go struct definition
type StructDef struct {
	Name   string
	Fields []FieldDef
}

// FieldDef represents a field within a struct.
type FieldDef struct {
	FieldName string // Go field name (exported)
	TypeName  string // Field type (e.g. string, bool, Database, []User, etc.)
	JSONKey   string // Original JSON key for the koanf tag.
	Setter    bool   // If true we add setter
	Tags      map[string]string
}

// processObject recursively processes a JSON object into a StructDef.
// It uses the given typeName (e.g. "Config", "Database") and
// stores the result in the types map.
func processObject(typeName string, obj map[string]any, types map[string]*StructDef, ext ExtensionConfig, parentPath string) {
	if parentPath == "" {
		parentPath = typeName
	}

	if _, exists := types[typeName]; exists {
		return
	}
	def := &StructDef{
		Name:   typeName,
		Fields: []FieldDef{},
	}
	types[typeName] = def

	keys := make([]string, 0, len(obj))
	for k := range obj {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, key := range keys {
		val := obj[key]
		fieldName := toCamel(key)
		var typeNameField string
		switch v := val.(type) {
		case map[string]any:
			nestedTypeName := toCamel(key)
			typeNameField = nestedTypeName
			processObject(nestedTypeName, v, types, ext, parentPath+"."+key)
		case []any:
			if len(v) > 0 {
				if elemObj, ok := v[0].(map[string]any); ok {
					singular := singularize(toCamel(key))
					typeNameField = "[]" + singular
					processObject(singular, elemObj, types, ext, parentPath+"."+key)
				} else {
					elemType := inferBasicType(v[0])
					typeNameField = "[]" + elemType
				}
			} else {
				typeNameField = "[]any"
			}
		default:
			typeNameField = inferBasicType(v)
		}

		def.Fields = append(def.Fields, FieldDef{
			FieldName: fieldName,
			TypeName:  typeNameField,
			JSONKey:   key,
		})
	}

	sort.Slice(def.Fields, func(i, j int) bool {
		return def.Fields[i].FieldName < def.Fields[j].FieldName
	})

	// apply extension configuration, if available
	normalized := normalizeKey(typeName)
	if extFields, ok := ext[normalized]; ok {
		applyExtensionFields(def, extFields)
	}

	// check for extensions using the full path
	normalizedPath := normalizeKey(parentPath)
	if extFields, ok := ext[normalizedPath]; ok && normalizedPath != normalized {
		applyExtensionFields(def, extFields)
	}

	sort.Slice(def.Fields, func(i, j int) bool {
		return def.Fields[i].FieldName < def.Fields[j].FieldName
	})
}

func applyExtensionFields(def *StructDef, extFields []ExtensionField) {
	for _, extField := range extFields {
		matched := false

		for i, field := range def.Fields {
			fname := normalizeKey(field.FieldName)
			if strings.EqualFold(fname, extField.Name) {
				fmt.Printf("override matching %s\n", field.FieldName)
				if extField.Overwrite != "" {
					def.Fields[i].FieldName = extField.Overwrite
				}

				if extField.Type != "" {
					def.Fields[i].TypeName = extField.Type
				}

				def.Fields[i].Setter = extField.Setter

				if extField.Tags != nil {
					def.Fields[i].Tags = extField.Tags
				}

				matched = true
				break
			}
		}

		if !matched && extField.Overwrite != "" && extField.Type != "" {
			fmt.Printf("override adding field: %s\n", extField.Name)
			def.Fields = append(def.Fields, FieldDef{
				FieldName: extField.Overwrite,
				TypeName:  extField.Type,
				JSONKey:   extField.Name,
				Setter:    extField.Setter,
				Tags:      extField.Tags,
			})
		}
	}
}

// inferBasicType returns the Go type for a given JSON primitive
func inferBasicType(val any) string {
	switch val.(type) {
	case string:
		return "string"
	case bool:
		return "bool"
	case float64:
		//NOTE: All numbers are unmarshaled as float64
		return "float64"
	default:
		return "any"
	}
}

func generateStruct(f *jen.File, def *StructDef) {
	fields := []jen.Code{}
	for _, field := range def.Fields {
		tags := map[string]string{
			"koanf": field.JSONKey,
			"json":  field.JSONKey,
		}

		for k, v := range field.Tags {
			tags[k] = v
			if v == "" {
				delete(tags, k)
			}
		}

		fields = append(fields,
			jen.Id(field.FieldName).
				Id(field.TypeName).
				Tag(tags),
		)
	}

	f.Type().Id(def.Name).Struct(fields...)
	f.Line()

	receiver := strings.ToLower(def.Name[:1])
	for _, field := range def.Fields {
		if field.Setter {
			// generate setter with signature:
			// func (r *StructName) Set<FieldName>(val <FieldType>) {
			//     r.<FieldName> = val
			// }
			f.Func().
				Params(jen.Id(receiver).Op("*").Id(def.Name)).
				Id("Set" + field.FieldName).
				Params(jen.Id("val").Id(field.TypeName)).
				Block(
					jen.Id(receiver).Dot(field.FieldName).Op("=").Id("val"),
				)
			f.Line()
		}
	}
}

func toCamel(s string) string {
	if s == "" {
		return ""
	}
	return strcase.ToGoPascal(s)
}

func singularize(s string) string {
	return pluralizer.Singular(s)
}

// extractBaseType returns the underlying type name for a field
// for type "[]User" or "*User" returns "User".
func extractBaseType(typ string) string {
	for {
		if strings.HasPrefix(typ, "[]") {
			typ = typ[2:]
		} else if strings.HasPrefix(typ, "*") {
			typ = typ[1:]
		} else {
			break
		}
	}
	return typ
}

// pruneTypes traverses the type graph starting at rootType (like "Config")
// and returns a new map containing only the types that are reachable
func pruneTypes(rootType string, types map[string]*StructDef) map[string]*StructDef {
	reachable := make(map[string]bool)

	var visit func(string)
	visit = func(t string) {
		if reachable[t] {
			return
		}
		def, ok := types[t]
		if !ok {
			return
		}
		reachable[t] = true
		for _, field := range def.Fields {
			base := extractBaseType(field.TypeName)
			if _, exists := types[base]; exists {
				visit(base)
			}
		}
	}

	visit(rootType)
	pruned := make(map[string]*StructDef)
	for k, v := range types {
		if reachable[k] {
			pruned[k] = v
		}
	}
	return pruned
}

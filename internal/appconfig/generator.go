package appconfig

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path"
	"sort"
	"strings"

	"github.com/BurntSushi/toml"
	"github.com/dave/jennifer/jen"
	"github.com/ettle/strcase"
	"github.com/gertd/go-pluralize"
	common "github.com/goliatone/go-generators/internal/common/generator"
	"golang.org/x/tools/imports"
	"gopkg.in/yaml.v3"
)

var pluralizer = pluralize.NewClient()

var (
	DefaultStructName  = "Config"
	DefaultPackageName = "config"
)

// Generator implements the app-config generator
type Generator struct {
	*common.BaseGenerator
}

// New creates a new app-config generator that writes to stdout
func New() *Generator {
	return &Generator{
		BaseGenerator: common.NewBaseGenerator("app-config", os.Stdout, false),
	}
}

// NewWithWriter creates a new app-config generator with the provided writer
func NewWithWriter(w io.Writer) *Generator {
	return &Generator{
		BaseGenerator: common.NewBaseGenerator("app-config", w, true),
	}
}

func unmarshalFile(filepath string) (any, error) {
	raw, err := os.ReadFile(filepath)
	if err != nil {
		return nil, fmt.Errorf("failed to read input file: %v", err)
	}

	var data any

	// check for file extension
	ext := path.Ext(filepath)
	switch ext {
	case ".json":
		if err := json.Unmarshal(raw, &data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal JSON: %v", err)
		}
	case ".yml", ".yaml":
		if err := yaml.Unmarshal(raw, &data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal YAML: %v", err)
		}
	case ".toml":
		if err := toml.Unmarshal(raw, &data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal JSON: %v", err)
		}
	default:
		return nil, fmt.Errorf("unknown extension: %s", ext)
	}

	return data, nil
}

// Generate implements the Generator interface
func (g *Generator) Generate(opts common.Options) error {
	return g.generateAppConfig(opts)
}

func (g *Generator) generateAppConfig(opts common.Options) error {
	data, err := unmarshalFile(opts.InputFile)
	if err != nil {
		return err
	}

	// we expect a top-level JSON object
	rootObj, ok := data.(map[string]any)
	if !ok {
		return fmt.Errorf("expected top-level JSON object")
	}

	types := make(map[string]*StructDef)

	ext := make(ExtensionConfig)
	if opts.ExtensionFile != "" {
		fmt.Println("Loading extension file...")
		ext, err = loadExtensionFile(opts.ExtensionFile)
		if err != nil {
			return err
		}
	}

	structName := opts.StructName
	if structName == "" {
		structName = DefaultStructName
	}

	packageName := opts.PackageName
	if packageName == "" {
		packageName = DefaultPackageName
	}

	// process the top level object as type "Config"
	processObject(structName, rootObj, types, ext, "")

	// remove orphaned types from ovewriting stuff
	types = pruneTypes(structName, types)

	f := jen.NewFile(packageName)

	f.HeaderComment(fmt.Sprintf("// Code generated by %s; DO NOT EDIT.", g.Name))

	// we now generate the types,
	// first output "Config" and then the rest
	if def, ok := types[structName]; ok {
		generateStruct(f, def)
		delete(types, structName)
	}

	var typeNames []string
	for tName := range types {
		typeNames = append(typeNames, tName)
	}
	sort.Strings(typeNames)
	for _, tName := range typeNames {
		generateStruct(f, types[tName])
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		return fmt.Errorf("failed to render code: %v", err)
	}

	// process the generated code using goimports
	// to format the code and adjust the imports
	processed, err := imports.Process(opts.OutputFile, buf.Bytes(), nil)
	if err != nil {
		return fmt.Errorf("failed to process imports on generated code: %v", err)
	}

	// If we provided a writer, we output there.
	// e.g. in tests to generate golden files
	if g.ToWritter {
		return common.Render(processed, g.Writer)
	}

	if err := common.CreateOutputDir(opts.OutputFile); err != nil {
		return fmt.Errorf("failed to create output directory: %v", err)
	}

	if err := os.WriteFile(opts.OutputFile, processed, 0644); err != nil {
		return fmt.Errorf("failed to write processed code to file: %v", err)
	}

	fmt.Printf("Successfully generated app %s in %s\n", opts.StructName, opts.OutputFile)
	return nil
}

// StructDef represents a Go struct definition
type StructDef struct {
	Name   string
	Fields []FieldDef
}

// FieldDef represents a field within a struct.
type FieldDef struct {
	FieldName string // Go field name (exported)
	TypeName  string // Field type (e.g. string, bool, Database, []User, etc.)
	JSONKey   string // Original JSON key for the koanf tag.
	Setter    bool   // If true we add setter
	Tags      map[string]string
}

// processObject recursively processes a JSON object into a StructDef.
// It uses the given typeName (e.g. "Config", "Database") and
// stores the result in the types map.
func processObject(typeName string, obj map[string]any, types map[string]*StructDef, ext ExtensionConfig, parentPath string) {
	if _, exists := types[typeName]; exists {
		return
	}

	def := &StructDef{
		Name:   typeName,
		Fields: []FieldDef{},
	}
	types[typeName] = def

	keys := make([]string, 0, len(obj))
	for k := range obj {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	nestedPath := func(key string) string {
		vpath := key
		if parentPath != "" {
			vpath = parentPath + "." + key
		}
		return vpath
	}

	for _, key := range keys {
		val := obj[key]
		var typeNameField string
		switch v := val.(type) {
		case map[string]any:
			typeNameField = createContextualTypeName(key, parentPath, types)
			processObject(typeNameField, v, types, ext, nestedPath(key))
		case []any:
			if len(v) > 0 {
				// find the object in the array with the most attributes
				fields := 0
				var elemObj map[string]any
				for _, item := range v {
					if obj, ok := item.(map[string]any); ok && len(obj) > fields {
						elemObj = obj
						fields = len(obj)
					}
				}

				if elemObj != nil {
					singular := singularize((toCamel(key)))
					typeNameField = "[]" + singular
					processObject(singular, elemObj, types, ext, nestedPath(key))
				} else if len(v) > 0 {
					if elemObj, ok := v[0].(map[string]any); ok {
						singular := createContextualTypeName(key, parentPath, types)
						typeNameField = "[]" + singular
						processObject(singular, elemObj, types, ext, nestedPath(key))
					} else {
						typeNameField = "[]" + inferBasicType(v[0])
					}
				} else {
					typeNameField = "[]any"
				}
			} else {
				typeNameField = "[]any"
			}
		default:
			typeNameField = inferBasicType(v)
		}

		def.Fields = append(def.Fields, FieldDef{
			FieldName: toCamel(key),
			TypeName:  typeNameField,
			JSONKey:   key,
		})
	}

	sort.Slice(def.Fields, func(i, j int) bool {
		return def.Fields[i].FieldName < def.Fields[j].FieldName
	})

	// apply modifications based on type name (backward compatibility)
	if extFields, ok := ext[normalizeKey(typeName)]; ok {
		applyExtensionFields(def, extFields)
	}

	// apply modifications based on JSON path
	if parentPath != "" {
		// try with the full path
		if extFields, ok := ext[parentPath]; ok {
			applyExtensionFields(def, extFields)
		}
		// try with shortened path (without e.g. BaseConfig prefix)
		if strings.HasPrefix(parentPath, typeName+".") {
			shortenedPath := strings.TrimPrefix(parentPath, typeName+".")
			if extFields, ok := ext[shortenedPath]; ok {
				applyExtensionFields(def, extFields)
			}
		}
	}

	sort.Slice(def.Fields, func(i, j int) bool {
		return def.Fields[i].FieldName < def.Fields[j].FieldName
	})
}

func applyExtensionFields(def *StructDef, extFields []ExtensionField) {
	// Helper function to check if a field already exists
	fieldExists := func(name string) bool {
		for _, field := range def.Fields {
			if field.FieldName == name {
				return true
			}
		}
		return false
	}

	for _, extField := range extFields {
		matched := false

		// first update existing fields
		for i, field := range def.Fields {
			fname := normalizeKey(field.FieldName)
			if strings.EqualFold(fname, extField.Name) {
				fmt.Printf("override matching %s with extension %s\n", field.FieldName, extField.Name)

				if extField.Overwrite != "" {
					def.Fields[i].FieldName = extField.Overwrite
				}

				if extField.Type != "" {
					fmt.Printf("Updating type for %s from %s to %s\n", field.FieldName, def.Fields[i].TypeName, extField.Type)
					def.Fields[i].TypeName = extField.Type
				}

				def.Fields[i].Setter = extField.Setter

				if extField.Tags != nil {
					def.Fields[i].Tags = extField.Tags
				}

				matched = true
				break
			}
		}

		// next add new fields if they don't exist yet
		if !matched && extField.Overwrite != "" && extField.Type != "" {
			// if field already exists prevent duplication
			if !fieldExists(extField.Overwrite) {
				fmt.Printf("override adding field: %s\n", extField.Name)
				def.Fields = append(def.Fields, FieldDef{
					FieldName: extField.Overwrite,
					TypeName:  extField.Type,
					JSONKey:   extField.Name,
					Setter:    extField.Setter,
					Tags:      extField.Tags,
				})
			} else {
				fmt.Printf("skipping duplicate field: %s\n", extField.Overwrite)
			}
		}
	}
}

// inferBasicType returns the Go type for a given JSON primitive
func inferBasicType(val any) string {
	switch val.(type) {
	case string:
		return "string"
	case bool:
		return "bool"
	case float64:
		//NOTE: All numbers are unmarshaled as float64
		return "float64"
	default:
		return "any"
	}
}

func generateStruct(f *jen.File, def *StructDef) {
	fields := []jen.Code{}
	for _, field := range def.Fields {
		tags := map[string]string{
			"koanf": field.JSONKey,
			"json":  field.JSONKey,
		}

		for k, v := range field.Tags {
			tags[k] = v
			if v == "" {
				delete(tags, k)
			}
		}

		fields = append(fields,
			jen.Id(field.FieldName).
				Id(field.TypeName).
				Tag(tags),
		)
	}

	f.Type().Id(def.Name).Struct(fields...)
	f.Line()

	receiver := strings.ToLower(def.Name[:1])
	for _, field := range def.Fields {
		if field.Setter {
			// generate setter with signature:
			// func (r *StructName) Set<FieldName>(val <FieldType>) {
			//     r.<FieldName> = val
			// }
			f.Func().
				Params(jen.Id(receiver).Op("*").Id(def.Name)).
				Id("Set" + field.FieldName).
				Params(jen.Id("val").Id(field.TypeName)).
				Block(
					jen.Id(receiver).Dot(field.FieldName).Op("=").Id("val"),
				)
			f.Line()
		}
	}
}

func toCamel(s string) string {
	if s == "" {
		return ""
	}
	return strcase.ToGoPascal(s)
}

func singularize(s string) string {
	return pluralizer.Singular(s)
}

// extractBaseType returns the underlying type name for a field
// for type "[]User" or "*User" returns "User".
func extractBaseType(typ string) string {
	for {
		if strings.HasPrefix(typ, "[]") {
			typ = typ[2:]
		} else if strings.HasPrefix(typ, "*") {
			typ = typ[1:]
		} else {
			break
		}
	}
	return typ
}

// pruneTypes traverses the type graph starting at rootType (like "Config")
// and returns a new map containing only the types that are reachable
func pruneTypes(rootType string, types map[string]*StructDef) map[string]*StructDef {
	reachable := make(map[string]bool)

	var visit func(string)
	visit = func(t string) {
		if reachable[t] {
			return
		}
		def, ok := types[t]
		if !ok {
			return
		}
		reachable[t] = true
		for _, field := range def.Fields {
			base := extractBaseType(field.TypeName)
			if _, exists := types[base]; exists {
				visit(base)
			}
		}
	}

	visit(rootType)
	pruned := make(map[string]*StructDef)
	for k, v := range types {
		if reachable[k] {
			pruned[k] = v
		}
	}
	return pruned
}

func extractStructNameFromPath(path string) string {
	parts := strings.Split(path, ".")
	lastPart := parts[len(parts)-1]
	lastPart = strings.TrimSuffix(lastPart, "[*]")
	return singularize(toCamel(lastPart))
}

func createContextualTypeName(key, parentPath string, types map[string]*StructDef) string {
	baseName := toCamel(key)

	// for array items use the singular name
	if strings.HasPrefix(parentPath, "[]") {
		baseName = singularize(baseName)
	}

	if _, exists := types[baseName]; exists {
		if parentPath != "" {
			parts := strings.Split(parentPath, ".")
			inmediateParent := parts[len(parts)-1]
			parentPrefix := toCamel(inmediateParent)
			if !strings.HasPrefix(baseName, parentPrefix) && !strings.HasSuffix(parentPrefix, baseName) {
				contextualName := parentPrefix + baseName
				return contextualName
			}
		}
	}
	return baseName
}
